## Goals: 
* modular design 
* easy to parallelize using Ray.
* maximize use of numpy operations instead of python loops.

## Main Classes:

### Cover:
defines a set of points each with location, weight and epsilon where epsilon is the e-radius for the point. Multi-epsilon cover is used when splitting a point in an epsilon cover to epsilon/2 requires a large number of points (is high-D)

### Vmap:
A cover + a source (single point)
**parameters:**
*  width (sigma in the Gaussian Kernel)
*  tolerance: the solver stops when the change in all points of the cover is smaller than the tolerance.

A map can be initialized from a rougher map.

The main method in Vmap is Vsolver

Points with voltage smaller than **minV** are eliminated from the cover.

Points whose epsilon is much larger than the width parameter are kept unchanged.

**Monitoring:** Monitoring is a  background operation that accumulates statistics. The monitor can be queried to get statistics.
* For each point in the cover: the number of iterations until convergence.

### Tree:
A tree is a  factory of Covers.

**max_rad** is the radius of a ball that contains all of the data.

It is the place where the data enters the system.

The covers generated by level i+1 includes all of 
the points for the cover at level i

Level i is associated with a radius of **max_rad** * 2^{-i}
but some of the cells might have a higher radius (high intrinsic dimension region)


